<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Stone Path</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #fff; }
    canvas { display: block; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>
<body>

<script>
// 랜덤 돌 생성 함수
const 石 = () => {
  // 화면보다 훨씬 넓은 범위에 분포시켜야 원근 변환 시 빈 공간이 안 보임
  const rangeX = width * 4; 
  
  return {
    x: random(-rangeX, rangeX),
    y: random(100, 200),    // 바닥 높이 (Y world position)
    z: random(1, 20),       // 깊이 범위 대폭 확대 (더 깊은 공간감)
    r: random(30, 0),     // 돌 기본 크기
    seed: random(1000),     // 노이즈 시드
    steps: int(random(12, 4)), // 정점 개수
    wobble: random(0.5, 2.5),   // 일그러짐 정도
    scaleRatio: random(0.8, 1.2) // 납작함 정도 다양화
  };
};

const 石道 = {
  stones: [],
  stoneCount: 30, // 1920px 화면을 채우기 위해 개수 증가

  初期化() {
    this.stones = [];
    for (let i = 0; i < this.stoneCount; i++) {
      this.stones.push(石());
    }
  },

  更新() {
    for (const s of this.stones) {
      // 1. 카메라 패닝 효과 (마우스 위치에 따라 부드럽게)
      // 화면이 넓으므로 이동 속도와 범위를 조정
      const panSpeed = (mouseX - width / 2) * 0.05;
      s.x -= panSpeed;

      // 2. 깊이(Z) 이동 효과
      // 마우스 Y에 따라 속도 조절, 로그 함수로 부드럽게
      const speedZ = map(mouseY, 0, height, 0, 0.2); 
      s.z -= speedZ;

      // 3. 루프 (화면 밖으로 나가면 재배치)
      // 깊이 리셋 (너무 가까워지면 다시 뒤로 보냄)
      if (s.z < 0.5) {
        s.z = 20; 
        const rangeX = width * (s.z * 0.3); // 멀리 있을 땐 넓게 퍼져야 함
        s.x = random(-rangeX, rangeX);
      }

      // 좌우 무한 스크롤 (원근감을 위해 Z값에 비례해 범위 체크)
      const boundX = width * (s.z * 0.8); 
      if (s.x > boundX) s.x -= boundX * 2;
      if (s.x < -boundX) s.x += boundX * 2;
    }

    // ★ 핵심: Painter's Algorithm (멀리 있는 것 -> 가까이 있는 것 순서 정렬)
    // z가 큰 것(멀리)부터 작은 것(가까이) 순으로 정렬해야
    // 가까운 돌이 먼 돌을 덮어씀 (선 겹침 방지)
    this.stones.sort((a, b) => b.z - a.z);
  },

  描く() {
    stroke(0);
    // ★ 핵심: 내부를 흰색으로 채워 뒤쪽 돌의 선을 가림
    fill(255); 

    for (const s of this.stones) {
      push();

      // 원근 투영 (Perspective Projection)
      // 숫자를 조정하여 카메라 렌즈(FOV) 느낌 조절
      const perspectiveScale = 800 / s.z; 
      
      const px = s.x / s.z * 1.5; // X 퍼짐 정도
      const py = s.y / s.z + (s.y * 0.1); // Y 높이감 + 약간의 바닥 굴곡
      const rr = s.r / s.z; // 거리 비례 크기

      translate(px, py);

      // 거리에 따른 선 굵기 변화 (가까우면 굵고, 멀면 얇게)
      // 너무 얇아지면 안 보이므로 최소값 설정
      strokeWeight(constrain(3 / s.z, 0.5, 3));

      // 돌 그리기
      beginShape();
      for (let i = 0; i < s.steps; i++) {
        const a = map(i, 0, s.steps, 0, TWO_PI);

        // 시간(frameCount)에 따른 미세한 움직임 줄이기 (더 돌처럼 보이게)
        // 움직임을 원하면 frameCount를 살리세요.
        let n = noise(
          s.seed + cos(a) * s.wobble,
          s.seed + sin(a) * s.wobble
        );

        // 반지름 계산 (노이즈 적용)
        const rad = rr * (0.5 + n * 1.0); 
        
        const vx = cos(a) * rad;
        const vy = sin(a) * rad * s.scaleRatio * 0.6; // 0.6을 곱해 납작한 돌 느낌

        vertex(vx, vy);
      }
      endShape(CLOSE);

      pop();
    }
  },
};

function setup() {
  createCanvas(windowWidth, windowHeight);
  石道.初期化();
}

function draw() {
  background(255);
  
  // 소실점(Vanishing Point) 설정
  // 화면 중앙, 약간 위쪽이 지평선이 되도록
  translate(width / 2, height / 2 + 100);

  石道.更新();
  石道.描く();
}

// 브라우저 크기 변경 시 캔버스 리사이징
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  石道.初期化(); // 돌 위치 재설정
}
</script>
</body>
</html>
